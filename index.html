<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="每个人的心底都有一座坟墓，是用来埋葬所爱的人的">
<meta property="og:type" content="website">
<meta property="og:title" content="桃树下的白手套">
<meta property="og:url" content="http://github.com/gayTao/gayTao.github.io.git/index.html">
<meta property="og:site_name" content="桃树下的白手套">
<meta property="og:description" content="每个人的心底都有一座坟墓，是用来埋葬所爱的人的">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="桃树下的白手套">
<meta name="twitter:description" content="每个人的心底都有一座坟墓，是用来埋葬所爱的人的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://github.com/gayTao/gayTao.github.io.git/"/>





  <title>桃树下的白手套</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">桃树下的白手套</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/28/现代操作系统笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/现代操作系统笔记/" itemprop="url">现代操作系统笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T15:11:19+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/28/现代操作系统笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/28/现代操作系统笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程线程模型"><a href="#进程线程模型" class="headerlink" title="进程线程模型"></a>进程线程模型</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><h4 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h4><p>允许多个程序同时进入内存并运行，其目的是为了提高系统效率。有多个逻辑程序计数器，由于只有一个物理CPU和一个程序计数器，因此每当程序运行时，逻辑程序计数器的内容就载入程序计数器</p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>一段时间间隔内，单处理器上有两个或以上的程序同时处于开始运行但尚未结束的状态</p>
<h4 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h4><p>进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。也称任务(task)，linux使用<strong>ps</strong>查看进程</p>
<ul>
<li>程序的一次执行过程</li>
<li>是正在运行程序的抽象</li>
<li>将一个CPU变幻成多个虚拟的CPU</li>
<li>系统资源以进程为单位分配，如内存·文件….每个具有独立的地址空间</li>
<li>操作系统将CPU调度给需要的进程</li>
</ul>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><p>操作系统用于管理控制进程的一个专门数据结构。记录进程的各种属性，描述进程的动态变化过程。</p>
<ul>
<li>PCB是系统感知进程存在的唯一标志-&gt;进程与PCB是一一对应的</li>
<li>进程表：所有进程的PCB集合</li>
</ul>
<h3 id="进程状态和状态转换"><a href="#进程状态和状态转换" class="headerlink" title="进程状态和状态转换"></a>进程状态和状态转换</h3><h4 id="程序的三种基本状态"><a href="#程序的三种基本状态" class="headerlink" title="程序的三种基本状态"></a>程序的三种基本状态</h4><ol>
<li>运行态(Running)</li>
<li>就绪态(Ready) 具备运行条件，没得到空闲CPU</li>
<li>等待态(阻塞态) </li>
</ol>
<p>1-&gt;2：运行进程用完了时间片或者一个高优先级进程进入就绪态，抢占正在运行的进程<br>1-&gt;3: 请求OS服务，等待I/O结果，等待另一进程提供消息<br>3-&gt;2:等待的事情发生了</p>
<p><strong>阻塞态不能直接到运行态,就绪态不能直接到阻塞态</strong></p>
<p>进程的其他状态</p>
<ol>
<li>创建(new) :已完成创建一进程必要的工作，如PID,PCB，但因为资源有限尚未同意执行该进程</li>
<li>终止(terminated)</li>
<li>挂起(suspend)：用于调节负载,进程不占用内存，其进程映像交换到到磁盘上</li>
</ol>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>原语(primitive)：原子操作(atomic)</strong>用于进程控制的原语有创建进程、撤销进程、阻塞进程、唤醒进程、改变进程优先级等</p>
<h4 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1.进程创建"></a>1.进程创建</h4><ul>
<li>给新进程分配一个唯一标识以及进程控制块</li>
<li>为进程分配虚拟地址空间</li>
<li>初始化PCB </li>
<li>设置相应的队列指针，如把进程插入就绪状态链表</li>
</ul>
<h4 id="2-进程撤销"><a href="#2-进程撤销" class="headerlink" title="2.进程撤销"></a>2.进程撤销</h4><p>结束进程 linux常用<strong>exit</strong>命令</p>
<h4 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="3.进程阻塞"></a>3.进程阻塞</h4><p>当被等待的事件未发生时，由进程自己执行阻塞原语</p>
<h4 id="4-Unix的几个进程控制操作"><a href="#4-Unix的几个进程控制操作" class="headerlink" title="4.Unix的几个进程控制操作"></a>4.Unix的几个进程控制操作</h4><ul>
<li>fork()  通过复制调用进程来建立新的程序,<strong>linux采用写时复制技术Copy on Write加快创建进程:</strong>即之前 UNIX 的fork是以一次一页的方式复制父进程的地址空间，太慢了，也浪费，因为子进程并不需要那么多的信息。Linux改进为写时复制，父进程将地址空间的设置为只读权限（对子进程来说），然后将地址空间的指针传递给子进程，当子进程对父进程的地址空间进行写操作的时候，就会将对应的那页复制出去，单独为子进程开辟一个空间。</li>
<li>exec()  </li>
<li>exit(）</li>
<li>wait(）</li>
</ul>
<h3 id="关于进程的讨论"><a href="#关于进程的讨论" class="headerlink" title="关于进程的讨论"></a>关于进程的讨论</h3><h4 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h4><p>系统进程和用户进程，前台进程和后台进程，cpu密集型进程和I/O密集型进程</p>
<h4 id="进程与程序区别"><a href="#进程与程序区别" class="headerlink" title="进程与程序区别"></a>进程与程序区别</h4><p>程序静态，比较长久，但进程动态有生命周期，一个程序对应多个进程</p>
<h4 id="进程映像-IMAGE-程序-数据-用户-内核-栈-PCB"><a href="#进程映像-IMAGE-程序-数据-用户-内核-栈-PCB" class="headerlink" title="进程映像(IMAGE):程序+数据+(用户,内核)栈+PCB"></a>进程映像(IMAGE):程序+数据+(用户,内核)栈+PCB</h4><h4 id="各进程的地址空间相互独立"><a href="#各进程的地址空间相互独立" class="headerlink" title="各进程的地址空间相互独立"></a>各进程的地址空间相互独立</h4><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程的一个运行实体，是CPU的调度单位。一个进程中的所有线程共享该进程的地址空间，但它们有各自独立的（私有的）栈(stack)。有以下三种实现</p>
<h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>在user space建立线程库，runtime system完成线程的管理工作，如操作，内核管理的还是进程，不知道线程的存在，线程切换不需要内核态的特权</p>
<p>该方法缺点是 大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程的所有线程都被阻塞</p>
<h4 id="核心级线程"><a href="#核心级线程" class="headerlink" title="核心级线程"></a>核心级线程</h4><p>内核管理所有线程管理，线程切换需要内核支持<br>例子 windows</p>
<h4 id="混合模型"><a href="#混合模型" class="headerlink" title="混合模型"></a>混合模型</h4><p>线程创建在用户空间完成，调度在内核空间完成</p>
<h2 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a>同步互斥机制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><p>由于各进程要求使用共享资源(变量,文件)，而这些资源需要排他使用，各进程竞争使用这些资源</p>
<h4 id="临界资源（共享资源，互斥资源，critical-resource）"><a href="#临界资源（共享资源，互斥资源，critical-resource）" class="headerlink" title="临界资源（共享资源，互斥资源，critical resource）"></a>临界资源（共享资源，互斥资源，critical resource）</h4><p>楼上的共享资源</p>
<h4 id="临界区（critical-section-region"><a href="#临界区（critical-section-region" class="headerlink" title="临界区（critical section(region)"></a>临界区（critical section(region)</h4><p>各个进程中某个临界资源(共享变量实施操作的程序片段)</p>
<h4 id="临界区的使用原则"><a href="#临界区的使用原则" class="headerlink" title="临界区的使用原则"></a>临界区的使用原则</h4><ol>
<li>如果没有进程在临界区 想进临界区的进程就可以进入临界区 </li>
<li>不允许两个进程 同时处于临界区中</li>
<li>临界区外运行的进程，不能阻塞 其他的进程进入临界区</li>
<li>不得使进程无限期的等待进入临界区</li>
</ol>
<h3 id="进程互斥的软件解法"><a href="#进程互斥的软件解法" class="headerlink" title="进程互斥的软件解法"></a>进程互斥的软件解法</h3><p>Peterson算法</p>
<h3 id="进程互斥的硬件解法"><a href="#进程互斥的硬件解法" class="headerlink" title="进程互斥的硬件解法"></a>进程互斥的硬件解法</h3><h4 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h4><ul>
<li>简单高效</li>
<li>临界区大的时候开销大</li>
<li>不适于多处理器</li>
<li>适用于os本身，不适用于用户进程，因为这是特权指令</li>
</ul>
<h4 id="自旋锁-“测试加锁”指令TEST-AND-SET-LOCK"><a href="#自旋锁-“测试加锁”指令TEST-AND-SET-LOCK" class="headerlink" title="自旋锁 “测试加锁”指令TEST AND SET LOCK"></a>自旋锁 “测试加锁”指令TEST AND SET LOCK</h4><p>专为防止<strong>多处理器</strong>并发保护共享资源引入的锁机制<br>enter_region：复制锁到寄存器并将锁置为1，判断寄存器内容是否是0，若不是0，跳转到enter_region否则返回调用者进入临界区<br>leve_region：在锁中置0，返回调用者</p>
<p>自旋锁与互斥锁有点类似，只是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。</p>
<p>可能会存在死锁问题</p>
<h4 id="“交换”指令-EXCHANGE"><a href="#“交换”指令-EXCHANGE" class="headerlink" title="“交换”指令 EXCHANGE"></a>“交换”指令 EXCHANGE</h4><p>与自旋锁不同的地方只在于开始是给寄存器置1，交换寄存器和锁内容，判断寄存器内容以下相同</p>
<h3 id="进程同步-synchronization"><a href="#进程同步-synchronization" class="headerlink" title="进程同步(synchronization)"></a>进程同步(synchronization)</h3><p>一个进程运行到某一点时，要求另一个伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态</p>
<h3 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和PV操作</h3><p>信号量是一种特殊变量，用于进程间传递信息的一个整数值</p>
<p>定义如下</p>
<pre><code>struct semaphore{
    int count;
    queueType queue;
}
</code></pre><p>P:对信号量的test操作 每次操作–，当小于0时阻塞<br>V：对信号量的increment操作 每次操作++，小于0时唤醒改成就绪态<br>P,V操作都是原语操作</p>
<p>用PV操作解决进程间互斥问题</p>
<ul>
<li>分析并发进程的关键活动，划定临界区</li>
<li>设置信号量mutex，初值为1</li>
<li>在临界区前实施P（mutex）</li>
<li>在临界区后实施V（mutex）</li>
</ul>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><p>一组生产者和消费者共享一个初始空，大小n的缓冲区。只有当缓冲区不满时，生产者才能放消息到缓冲区，否则必须等待。缓冲区非空时，消费者才能取出消息，否则必须等待。缓冲区是临界资源，只能一个生产者放入消息或一个消费者取出信息。</p>
<p>分析：</p>
<ul>
<li>生产者和消费者对缓冲区的访问是互斥的，但是生产者生产后消费者才能消费，他们也是同步关系</li>
<li>信号量mutex是互斥信号量，用于控制互斥访问缓冲池，初值为1；信号量full用于记录满的缓冲区数量，初值为0；信号量empty用于记录当前缓冲池中“空”缓冲区数量，初值为n</li>
</ul>
<p>生产者消费者进程的描述如下</p>
<pre><code>semaphore mutex = 1;
semaphore full = 0;
semaphore empty = n;

producer(){
    while(1){
    produce an item
    P(empty)
    P(mutex)
    add an item to buffer
    V(mutex)
    V(full)
    }
}
Consumer(){
    while(1){
    P(full)
    P(mutex)
    remove an item from buffer
    V(mutex)
    V(empty)    
    }
}
</code></pre><p>上面这个问题的P操作不可以互换 V操作可以</p>
<h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>有读者和写者两组并发进程共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但是某个写进程和其他读或者写进程同时访问共享数据会出错。</p>
<p>分析：</p>
<ul>
<li>读和写互斥，写和写互斥，读和读不存在关系</li>
<li>写进程和任何进程互斥，读进程除了和写进程互斥同时还要实现与其他读者的同步。故使用一个计数器，判断当前有没有读者读。不同读者对于计数器的访问是互斥的。</li>
<li>信号量count为计数器，记录读者数量，初值0；信号量mutex互斥，保护更新count时的互斥；信号量rw保证读者写者互斥</li>
</ul>
<pre><code>int count = 0; 
semaphore mutex = 1;
semaphore rw = 1;
writer(){
    while(1){
        P(rw);
        Writing;
        V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
        if(count == 0)
            P(rw);
        count++;
        V(mutex);
        Reading;
        P（mutex);
        count--;
        if(count == 0)
            V(rw);        
        V(mutex);
    }
}
</code></pre><p>####哲学家进餐问题<br>假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。</p>
<p>分析：</p>
<ul>
<li>当5个哲学家都想就餐时，分别都拿起左边的筷子，筷子都拿光了，等待想拿右边筷子，全部被阻塞。为了防止这种死锁，可以添加限制条件，比如最多允许4个哲学家同时就餐，只当一个哲学家左右两边筷子可才允许抓起筷子等等</li>
</ul>
<p>###管程（monitor，一种高级同步机制，程序设计语言的一个特殊模块）<br>它的出现是为了弥补信号量机制的不足：程序编写困难，容易出错</p>
<ul>
<li>由关于共享资源的数据结构及在上操作的一组过程组成</li>
</ul>
<p>进程只能通过调用管程中的过程间接访问管程中的数据结构</p>
<p>作为一种同步机制，管程需要解决</p>
<ul>
<li>管程是互斥进入的–为了保证管程中数据结构的数据完整性。<strong>管程的互斥性是由编译器负责保证的</strong></li>
<li>管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时应释放管程的使用权)，也可以通过发送信号将等待在条件变量上的进程或线程唤醒</li>
</ul>
<h4 id="HORE管程说明"><a href="#HORE管程说明" class="headerlink" title="HORE管程说明"></a>HORE管程说明</h4><p><img src="http://i.imgur.com/JkRAuQ4.jpg" alt=""></p>
<ul>
<li>因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待—-为此，管程的入口处设置一个进程等待队列，称作<strong>入口等待队列</strong></li>
<li>如果进程P唤醒进程Q,则P等待Q执行；如果进程Q执行中又唤醒进程R，则Q等待执行。。。如此在管程内部可能会出现多个等待进程——在管程内设置一个优先级比入口等待队列高的<strong>紧急等待队列</strong></li>
<li>条件变量var c:condition—在管程内部说明和使用的一种特殊类型的变量。对于条件变量，可以执行wait和signal操作<br>wait(c):如果紧急等待队列非空，则唤醒第一个等待者；否则释放进程的互斥权，执行此操作的进程进入c链末尾<br>signal(c)：如果c链为空，则相当空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾</li>
</ul>
<h4 id="管程的应用"><a href="#管程的应用" class="headerlink" title="管程的应用"></a>管程的应用</h4><p>管程实现的两个主要途径</p>
<ul>
<li>直接构造 -&gt; 效率高</li>
<li>间接构造 -&gt;用某种已经实现的同步机制实现<br>C/C++不支持管程</li>
</ul>
<h4 id="用管程解决生产者消费者问题"><a href="#用管程解决生产者消费者问题" class="headerlink" title="用管程解决生产者消费者问题"></a>用管程解决生产者消费者问题</h4><pre><code>monitor ProducerConsumer
    condition full,empty;
    integer count;

    producer insert(item；interger);
    begin 
        if count == N then wait(full);
        insert_item(item); count++;
        if count == 1 then signal(empty);
    end

    function remove:integer;
    begin 
        if count == 0 then wait(empty)
        remove = remove_item;count--;
        if count == N-1 then sinal(full)
    end
    count:=0
end monitor

procedure producer;
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item)
    end
end;

procedure consumer;
begin 
    while true do 
    begin
        item = ProducerConsumer.remove;
        consumer_item(item);
    end
end
</code></pre><h3 id="MESA管程"><a href="#MESA管程" class="headerlink" title="MESA管程"></a>MESA管程</h3><p> HOARE管程缺点:两次额外的进程切换<br>解决: sinal-&gt;notify</p>
<ul>
<li>notify:当一个正在管程中的进程执行notify(x)时，它使得X条件队列得到通知，发信号的进程继续执行</li>
<li>notify的结果：位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行</li>
<li>由于不能保证它之前没有其他进程进入管程，因此这个进程必须重新检查条件-&gt;用while循环取代if语句</li>
<li>导致对条件变量至少多一次额外的检测，但不再有额外的进程切换，并且对等待进程在notify之后何时运行没有任何限制</li>
</ul>
<p>还可以将notify作以下改进</p>
<ul>
<li>超时检测。进程超时以后进入就绪态，用条件变量检测是否该执行</li>
<li>broadcast：使所有在该条件上等待的进程都被释放并进入就绪队列<br>当一个进程不知道有多少进程将被激活时，这种方式很方便</li>
</ul>
<h4 id="MESA和HOARE管程比较"><a href="#MESA和HOARE管程比较" class="headerlink" title="MESA和HOARE管程比较"></a>MESA和HOARE管程比较</h4><p>MESA管程出错几率小</p>
<h4 id="管程小结"><a href="#管程小结" class="headerlink" title="管程小结"></a>管程小结</h4><p>管程：抽象数据类型</p>
<p>有一个明确定义的操作集合，通过它且只有通过它才能操纵该数据类型的实例<br>实现管程结构必须保证：</p>
<ul>
<li>只能通过管程的某个过程才能访问资源</li>
<li>管程是互斥的，某个时刻只能有一个进程或线程调用管程中的过程<br>条件变量:未提供进程与其他进程通信或同步而引入<br>wait/signal或wait/notify或wait/broadcast</li>
</ul>
<h3 id="进程间通信机制IPC"><a href="#进程间通信机制IPC" class="headerlink" title="进程间通信机制IPC"></a>进程间通信机制IPC</h3><p>基本通信方式</p>
<ul>
<li>消息传递 send &amp; receive原语<br>适用于：分布式系统，基于共享内存的多处理机系统，单处理机系统，可以解决进程间的同步问题，通信问题</li>
<li>共享内存</li>
<li>管道通信方式pipe</li>
</ul>
<h3 id="典型操作系统的IPC机制"><a href="#典型操作系统的IPC机制" class="headerlink" title="典型操作系统的IPC机制"></a>典型操作系统的IPC机制</h3><p>屏障(BARRIER)</p>
<ul>
<li>一种同步机制，用于对一组线程进行协调</li>
<li>应用场景：一组线程协同完成一项任务，需要所有线程到达一个汇合点后再一起向前推进。<em>比如说我们要做一个非常数量非常大的，规模非常大的一个矩阵运算。我们可能要做很多次的迭代。那么在每一次迭代的过程中，由于一个矩阵很大，我们又把这个矩阵呢，划分成了很多很多的小矩阵然后让每一个线程去完成一个小矩阵的计算。每一次迭代的话，每个小矩阵都计算完了，那么就才能进入下一次迭代。 假定有的线程运行得快一点，有的线程运行得慢一点，但是当这一次迭代，每个线程都完成了小矩阵的计算，那么这一次迭代才能算全部完成。这种情况下呢，我们就可以用这种屏障的机制，把这些线程让它们达到这个一个汇合点之后再往前走。</em></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/27/Scala-basic-1-工程构建，基础概念，与-编程风格建建议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/27/Scala-basic-1-工程构建，基础概念，与-编程风格建建议/" itemprop="url">Scala basic(1) 工程构建，基础概念，与 编程风格建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-27T19:42:46+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/27/Scala-basic-1-工程构建，基础概念，与-编程风格建建议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/27/Scala-basic-1-工程构建，基础概念，与-编程风格建建议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-开发环境配置与工程构建"><a href="#1-开发环境配置与工程构建" class="headerlink" title="1. 开发环境配置与工程构建"></a>1. 开发环境配置与工程构建</h3><h4 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h4><p>开发的准备非常简单，只有以下两步：</p>
<ol>
<li>在官网下载JDK,sbt,IDEA并安装,打开命令行分别输入<code>java -version</code>和<code>sbt aout</code>,出现版本号信息，说明JDK和sbt安装成功</li>
<li>IDEA安装Scala插件：Configure-&gt;Plugins-&gt;搜索Scala并下载</li>
</ol>
<h4 id="工程构建工具sbt的入门简单介绍"><a href="#工程构建工具sbt的入门简单介绍" class="headerlink" title="工程构建工具sbt的入门简单介绍"></a>工程构建工具sbt的入门简单介绍</h4><p>sbt是Scala的构建工具，它的地位等同于java的maven。其官方手册地址是<a href="http://www.scala-sbt.org/0.13/docs/Getting-Started.html" title="sbt ref manual" target="_blank" rel="external">http://www.scala-sbt.org/0.13/docs/Getting-Started.html</a>，民间还流传它的一个较好的tutorial版本<a href="https://github.com/shekhargulati/52-technologies-in-2016/blob/master/02-sbt/README.md" title="sbt tutor">https://github.com/shekhargulati/52-technologies-in-2016/blob/master/02-sbt/README.md</a>。</p>
<ol>
<li><p>为使后面的工作简单不混乱，sbt约定了工程的目录结构，如下图所示</p>
<pre><code>src/
  main/
    resources/
       &lt;files to include in main jar here&gt;
    scala/
       &lt;main Scala sources&gt;
    java/
       &lt;main Java sources&gt;
  test/
    resources
       &lt;files to include in test jar here&gt;
    scala/
       &lt;test Scala sources&gt;
    java/
       &lt;test Java sources&gt;
Other directories in src/ will be ignored. Additionally, all hidden
directories will be ignored.
</code></pre></li>
</ol>
<ol>
<li>在IDEA中按<code>Alt+F12</code>打开shell，输入sbt可以启动sbt程序，下图展示启动成功<br><img src="http://i.imgur.com/OhfpkQR.jpg" alt=""><br>接下来可以输入任务名，如<code>console</code>，则在sbt中运行scala解释器（按<code>Ctrl+D退出</code>）,亦或<code>compile</code>,<code>test</code>,<code>run</code>等等</li>
</ol>
<h3 id="2-Scala基础概念"><a href="#2-Scala基础概念" class="headerlink" title="2.Scala基础概念"></a>2.Scala基础概念</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Scala的class概念和java相似，不同在于Scala有特殊的一种class——case class以及Scala没有静态成员，但是你可以使用ojects实现类似的功能。</p>
<h4 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h4><p>这类似于java的interface概念，只不过Traits可以有方法的实现等等</p>
<h3 id="3-编程风格建议"><a href="#3-编程风格建议" class="headerlink" title="3.编程风格建议"></a>3.编程风格建议</h3><ul>
<li>Common Subexpressions </li>
</ul>
<p>比如 <code>this.remove(this.findMin).ascending(t + this.findMin)</code>，为了节省this.findMin的开销，应该做以下优化</p>
<pre><code>val min = this.findMin
this.remove(min).ascending(t + min)
</code></pre><ul>
<li>Don’t Copy-Paste Code</li>
</ul>
<p>应该提取相同部分为函数，重构代码</p>
<ul>
<li>Avoid using Return</li>
</ul>
<p>关于这一点，我目前体会不够深刻，等到时候有实例了再来补充</p>
<ul>
<li>Avoid mutable local Variables</li>
</ul>
<p>为了减少side effects，体现函数式编程的优势，应尽可能用helper funtion来替代局部变量<br>比如 修改前<br>    def fib(n: Int): Int = {<br>      var a = 0<br>      var b = 1<br>      var i = 0<br>      while (i &lt; n) {<br>        val prev_a = a<br>        a = b<br>        b = prev_a + b<br>        i = i + 1<br>      }<br>      a<br>    }<br>修改后<br>    def fib(n: Int): Int = {<br>      def fibIter(i: Int, a: Int, b: Int): Int =<br>        if (i == n) a else fibIter(i+1, b, a+b)<br>      fibIter(0, 0, 1)<br>    }</p>
<ul>
<li>Eliminate redundant “If” Expressions</li>
</ul>
<p><code>if(cond) true else false</code>  改为 <code>cond</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/27/bash常见文本处理命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/27/bash常见文本处理命令/" itemprop="url">bash常见文本处理命令（含常见正则表达式查询表）(updating)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-27T16:09:15+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/27/bash常见文本处理命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/27/bash常见文本处理命令/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>(更新中)</p>
<h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>用来删除一段文本信息中的某些文字。或者将其进行转换</p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td style="text-align:left">删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配</td>
</tr>
<tr>
<td>-s</td>
<td style="text-align:left">去除set1指定的在输入文本中连续并重复的字符</td>
</tr>
</tbody>
</table>
<p>操作举例</p>
<pre><code># 删除 &quot;hello shiyanlou&quot; 中所有的&apos;o&apos;,&apos;l&apos;,&apos;h&apos;
$ echo &apos;hello shiyanlou&apos; | tr -d &apos;olh&apos;
# 将&quot;hello&quot; 中的ll,去重为一个l
$ echo &apos;hello&apos; | tr -s &apos;l&apos;
# 将输入文本，全部转换为大写或小写输出
$ cat /etc/passwd | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;
</code></pre><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>打印每一行的某一字段</p>
<pre><code>cut -c 8-              #只保留每一行第8个字符以后的字段
cut /etc/passwd -d &apos;:&apos; -f 1,6   
</code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>在文本中或 stdin 中查找匹配字符串</p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td style="text-align:left">将二进制文件作为文本来进行匹配</td>
</tr>
<tr>
<td>-c</td>
<td style="text-align:left">统计以模式匹配的数目</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:left">忽略大小写</td>
</tr>
<tr>
<td>-n</td>
<td style="text-align:left">显示匹配文本所在行的行号</td>
</tr>
<tr>
<td>-v</td>
<td style="text-align:left">反选，输出不匹配行的内容</td>
</tr>
<tr>
<td>-r</td>
<td style="text-align:left">递归匹配查找</td>
</tr>
<tr>
<td>-A n</td>
<td style="text-align:left">n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行</td>
</tr>
<tr>
<td>-B n</td>
<td style="text-align:left">n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行</td>
</tr>
<tr>
<td>–color=auto</td>
<td style="text-align:left">将输出中的匹配项设置为自动颜色显示</td>
</tr>
</tbody>
</table>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>将两个文件中包含相同内容的那一行合并在一起</p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>###正则表达式</p>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:left">匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:left">匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:left">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td>{n,}</td>
<td style="text-align:left">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td style="text-align:left">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:left">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:left">匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td>
</tr>
<tr>
<td>(pattern)</td>
<td style="text-align:left">匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td>x｜y</td>
<td style="text-align:left">匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td style="text-align:left">字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td style="text-align:left">排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td style="text-align:left">排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/25/是时候点一波技能展开树了/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/是时候点一波技能展开树了/" itemprop="url">skills mapping</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T15:34:00+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/25/是时候点一波技能展开树了/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/25/是时候点一波技能展开树了/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i.imgur.com/IBIt9NZ.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/25/linux常见命令-updating/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/25/linux常见命令-updating/" itemprop="url">linux常见命令(updating)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T15:22:39+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/25/linux常见命令-updating/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/25/linux常见命令-updating/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（更新中)</p>
<h3 id="1-重要快捷键"><a href="#1-重要快捷键" class="headerlink" title="1.重要快捷键"></a>1.重要快捷键</h3><table>
<thead>
<tr>
<th>按键</th>
<th style="text-align:left">快捷键      </th>
</tr>
</thead>
<tbody>
<tr>
<td>[tab]</td>
<td style="text-align:left">命令补全</td>
</tr>
<tr>
<td>[Ctrl+c]</td>
<td style="text-align:left">强制终止当前程序</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td style="text-align:left">键盘输入结束或退出终端 </td>
</tr>
<tr>
<td>Ctrl+s</td>
<td style="text-align:left">暂停当前程序，暂停后按下任意键恢复运行</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td style="text-align:left">将当前程序放到后台运行，恢复到前台为命令fg</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td style="text-align:left">将光标移至输入行头，相当于Home键</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td style="text-align:left">将光标移至输入行末，相当于End键</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td style="text-align:left">删除从光标所在位置到行末</td>
</tr>
<tr>
<td>Alt+Backspace</td>
<td style="text-align:left">向前删除一个单词</td>
</tr>
<tr>
<td>Shift+PgUp</td>
<td style="text-align:left">将终端显示向上滚动</td>
</tr>
<tr>
<td>Shift+PgDn</td>
<td style="text-align:left">将终端显示向下滚动</td>
</tr>
</tbody>
</table>
<h3 id="2-用户管理权限"><a href="#2-用户管理权限" class="headerlink" title="2.用户管理权限"></a>2.用户管理权限</h3><h6 id="查看所属用户组并添加root权限"><a href="#查看所属用户组并添加root权限" class="headerlink" title="查看所属用户组并添加root权限"></a>查看所属用户组并添加root权限</h6><p> <code>groups &lt;用户名&gt;</code><br> <code>sudo usermod -G sudo &lt;用户名&gt;</code><br><img src="http://i.imgur.com/gBLI7WV.jpg" alt=""><br><img src="http://i.imgur.com/IwV6ubA.jpg" alt=""></p>
<h6 id="为了方便管理和操作，我们添加一个用户-git-并给他设置工作目录："><a href="#为了方便管理和操作，我们添加一个用户-git-并给他设置工作目录：" class="headerlink" title="为了方便管理和操作，我们添加一个用户 git ,并给他设置工作目录："></a>为了方便管理和操作，我们添加一个用户 git ,并给他设置工作目录：</h6><pre><code>$ sudo useradd git
$ sudo passwd  git  # 设置密码,为了方便操作，密码较为的简单
$ sudo mkdir /home/git   # 设置 git 用户的工作目录
$ sudo chown -R  git /home/git  #将工作目录的权限给git用户
$ ssh-keygen -t rsa #生成密钥
$ su git    # 切换用户到git,在本实验中用户权限的使用很重要
$ su -l git   #git用户免密登录
</code></pre><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3.文件管理"></a>3.文件管理</h3><pre><code>$ ls -a  查看隐藏文件
$ ll &lt;文件名&gt; 查看权限的命令
$ cp &lt;文件&gt; &lt;目录&gt;   复制文件
$ cp -r &lt;目录&gt; &lt;目录&gt;
$ rm &lt;文件&gt;  rm -r&lt;目录&gt;  删除文件/目录
$ mv 源目录文件 目的目录  移动文件
$ mv 旧的文件名 新的文件名  重命名文件
$ rename 批量重命名
$ charp 改变文件所属用户组
$ chown 改变文件的所有者
$ chmod 改变文件的权限
head,tail,more,less，cat,nl 等查看文件的操作具体参考man手册
</code></pre><p>如果你有一个自己的文件不想被其他用户读r、写w、执行x，那么就需要对文件的权限做修改，这里有两种方式：</p>
<h4 id="二进制数字表示"><a href="#二进制数字表示" class="headerlink" title="二进制数字表示"></a>二进制数字表示</h4><p>每个文件的三组权限（拥有者，所属用户组，其他用户，记住这个顺序是一定的）对应一个 “ rwx “ ，所以如果我要将文件“ iphone6 ”的权限改为只有我自己可以用那么就这样：<br>    `chmod 700 iphone6```</p>
<h4 id="加减赋值操作"><a href="#加减赋值操作" class="headerlink" title="加减赋值操作"></a>加减赋值操作</h4><p><code>g、o</code> 还有 <code>u</code> 分别表示 <code>group所属用户组、others其他用户</code> 和 <code>user</code>，<code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限</p>
<p><strong>*注意</strong>：目录的x代表用户能否进入该目录成为工作目录，如果对于一个目录只有r没有x权限，则只能读取该目录下的文件名，但是无法进入到该目录下，因此一般来说开发目录给任何人浏览时至少给予rx权限但w不要随便给*</p>
<h3 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4.目录结构"></a>4.目录结构</h3><pre><code>$ pwd获取当前路径
</code></pre><p> Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用 <em>网络文件系统（Network File System，NFS）服务器</em> 载入某特定目录等。</p>
<p> Linux的目录结构遵守FHS标准，如下图<br><img src="http://i.imgur.com/Eskqr1r.png" alt=""></p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>./</td>
<td style="text-align:left">当前目录</td>
</tr>
<tr>
<td>../</td>
<td style="text-align:left">上一级目录</td>
</tr>
<tr>
<td>文件名前有.</td>
<td style="text-align:left">隐藏文件</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:left">上一次所在目录</td>
</tr>
<tr>
<td>~</td>
<td style="text-align:left">当前用户的home</td>
</tr>
</tbody>
</table>
<h3 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5.环境变量"></a>5.环境变量</h3><p>####1. 变量的赋值,读取和删除<br>    $ tmp=shiyanlou  #赋值<br>    $ echo $tmp         #读取<br>    $ unset tmp         #删除</p>
<h4 id="2-环境变量的设置"><a href="#2-环境变量的设置" class="headerlink" title="2.环境变量的设置"></a>2.环境变量的设置</h4><p>环境变量的定义是在当前进程的子进程有效的变量</p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td style="text-align:left">显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。</td>
</tr>
<tr>
<td>env</td>
<td style="text-align:left">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。</td>
</tr>
<tr>
<td>export</td>
<td style="text-align:left">显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</td>
</tr>
</tbody>
</table>
<p>以下是实例<br><img src="http://i.imgur.com/AUUeYtz.png" alt=""><br>按变量的生存周期来划分，Linux 变量可分为两类：</p>
<ul>
<li>永久的：需要修改配置文件，变量永久生效；</li>
</ul>
<ul>
<li>临时的：使用 export 命令行声明即可，变量在关闭 shell 时失效。</li>
</ul>
<p>这里介绍三个重要文件 /etc/bashrc（有的 Linux 没有这个文件） 和 /etc/profile 以及是每个用户目录下的一个隐藏文件(使用<code>ls -a</code>命令查看)： ，它们分别存放的是 shell 变量和全局环境变量和当前用户的环境变量 只需要修改里面的内容就能改变环境变量</p>
<h6 id="3-命令的环境变量"><a href="#3-命令的环境变量" class="headerlink" title="3.命令的环境变量"></a>3.命令的环境变量</h6><pre><code>$ echo $PATH    #查看命令的环境变量 
$ PATH=$PATH:/home/shiyanlou/mybin      #把&quot;/home/shiyanlou/mybin&quot;这个目录添加到环境变量 但是这个方法只在当前shell有效，因此需要添加下一步
$ echo &quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .bashr         #bash每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等 etc和用户目录都有.bashrc不过通常只修改用户目录下的配置文件
$ souce .bashrc      #让环境变量立即生效
</code></pre><h3 id="5-文件查找"><a href="#5-文件查找" class="headerlink" title="5.文件查找"></a>5.文件查找</h3><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>whereis  &lt;文件名&gt;</td>
<td style="text-align:left">只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)</td>
</tr>
<tr>
<td>locate &lt;文件名&gt;</td>
<td style="text-align:left">使用该命令前需要先执行<code>sudo updatedb</code>，可以用来查指定目录及其子目录下特定类型的文件 如<code>$ locate /usr/share/\*.jpg</code></td>
</tr>
<tr>
<td>which &lt;软件名&gt;</td>
</tr>
<tr>
<td>find [path] [option] [action]</td>
<td style="text-align:left">find /etc/ -name sources.list</td>
</tr>
</tbody>
</table>
<h3 id="6-文件打包和解压"><a href="#6-文件打包和解压" class="headerlink" title="6.文件打包和解压"></a>6.文件打包和解压</h3><table>
<thead>
<tr>
<th>文件后缀名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.zip</td>
<td style="text-align:left">zip 程序打包压缩的文件</td>
</tr>
<tr>
<td>*.rar</td>
<td style="text-align:left">rar 程序压缩的文件</td>
</tr>
<tr>
<td>*.7z</td>
<td style="text-align:left">7zip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar</td>
<td style="text-align:left">tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td>*.gz</td>
<td style="text-align:left">gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td>*.xz</td>
<td style="text-align:left">xz 程序压缩的文件</td>
</tr>
<tr>
<td>*.bz2</td>
<td style="text-align:left">bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td style="text-align:left">tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td style="text-align:left">tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td>*tar.bz2</td>
<td style="text-align:left">tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td>*.tar.7z</td>
<td style="text-align:left">tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody>
</table>
<pre><code>zip：
    打包 ：zip something.zip something （目录请加 -r 参数）
    解包：unzip something
    指定路径：-d 参数
tar：
    打包：tar -zcvf something.tar something
    解包：tar -zxvf something.tar
    指定路径：-C 参数
</code></pre><h3 id="7-常见命令"><a href="#7-常见命令" class="headerlink" title="7.常见命令"></a>7.常见命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>crontab</td>
</tr>
<tr>
<td>wc</td>
<td style="text-align:left">计字数</td>
</tr>
<tr>
<td>sort</td>
<td style="text-align:left">排序</td>
</tr>
<tr>
<td>unique</td>
<td style="text-align:left">去重复</td>
</tr>
</tbody>
</table>
<p>更多和详细的命令见bash常见文本处理命令详解</p>
<h3 id="8-管道与重定向"><a href="#8-管道与重定向" class="headerlink" title="8.管道与重定向"></a>8.管道与重定向</h3><p>管道是一种通信机制，通常用于进程间的通信。匿名管道，在命令行中由<code>|</code>分隔符表示。<br>管道默认是连接前一个命令的输出到下一个命令的输入，而重定向通常是需要一个文件来建立两个命令的连接。</p>
<p><code>&gt;</code> 标准输出覆盖新文件<br><code>&gt;&gt;</code> 标准输出追加新文件</p>
<h3 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h3><pre><code>$ rpm -q &lt; rpm package name&gt;查询有没有安装包
$ service sshd start  或者使用 /etc/init.d/sshd start   启动ssh服务


$ tar -zxvf pycharm-community-5.0.1.tar.gz  解压
$ sh pycharm-community-5.0.1/bin/pycharm.sh  执行程序
</code></pre><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><pre><code>$ ssh-keygen -t rsa   #一路回车
$ cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys
$ chmod 600 .ssh/authorized_keys
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/22/Spark学学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/22/Spark学学习笔记/" itemprop="url">Spark学习笔记（1）术语概览(updating)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T17:09:06+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/22/Spark学学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/22/Spark学学习笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：根据网站<a href="https://databricks.com/" title="databricks" target="_blank" rel="external">https://databricks.com/</a>整理</p>
<p> spark核心共有4个模块，面对的实际情景如下图所示<br><img src="http://i.imgur.com/YN9lQ4W.jpg" alt=""></p>
<h3 id="RDD-Resilient-Distribute-Datasets"><a href="#RDD-Resilient-Distribute-Datasets" class="headerlink" title="RDD(Resilient Distribute Datasets)"></a>RDD(Resilient Distribute Datasets)</h3><p>目前，我对spark的理解浅显的停留在一种是大数据处理的框架。那么，要处理数据，就必须了解其中重要的操作元素RDD的概念。RDD在官网的定义是：It is a fault-tolerant collection of elements that can be operated on in parallel<br>.即可以并行操作的容错集合元素。它支持两种操作： transformations和actions。transformation指从原有数据按照一定规则创造出新的数据集，一个相关的典例就是常见的map操作。actions指运行完操作数据集的程序后会返回一个值，对应典例是reduce。</p>
<h3 id="SQL-DataSet和DataFrame"><a href="#SQL-DataSet和DataFrame" class="headerlink" title="SQL,DataSet和DataFrame"></a>SQL,DataSet和DataFrame</h3><p>Spark SQL 是 Spark 处理结构化数据的一个模块，功能是执行SQL查询，返回DataSet/DataFrame的查询结果。</p>
<p>一个DataSet 是一个分布式数据集，scala/java支持Dataset api，但是python不支持。</p>
<p>一个 DataFrame 所代表的是一个多个 Row（行）的 Dataset，类似关系型数据库中表的概念。Scala，java，python 和 R 均支持DataFrame api。DataFrame 可以从大量的 Source 中构造出来，像 : 结构化的数据文件，Hive中的表，外部的数据库，或者已存在的 RDD。可见，它是一种跨语言的、通用的数据科学抽象。<br><strong>总之，DataFrame 可以理解为以RDD为基础的，结构化带有模式信息的分布式数据集，具有额外的SQL接口。</strong><br>DataFrame 是按照指定列组织的分布式数据集合。</p>
<pre><code>是 SparkSQL 中的编程抽象。
支持广泛的数据格式和存储系统。
可通过 Scala、Python、Java 和 R 语言编程。
</code></pre><p>DataFrame 与 Spark RDD 的区别在于：</p>
<pre><code>DataFrame 是带有模式的集合，可以通过 SQL 语句查询。
RDD 是不具有潜在数据类型信息的对象的不透明集合，不能通过 SQL 语句查询
</code></pre><h3 id="Spark-Stream"><a href="#Spark-Stream" class="headerlink" title="Spark Stream"></a>Spark Stream</h3><p>Spark Streaming 是现有 Spark 核心 API 的一种扩展，适用于实时数据在可扩展、高吞吐、高容错等特性下的流处理。<br><img src="http://i.imgur.com/6DavYrm.png" alt=""><br>Spark Streaming 可以接收实时的数据流，然后将其划分为 Batch （可以理解为各个批次的数据块）。这些 Batch 将由真正的 Spark 引擎来处理，创建最后的处理结果的数据流，并且这些数据流也是以 Batch 的形式存在的。它们通常可以存放至 HDFS、HBase 等处。后续可以继续用 Spark 进行处理，或者是导向 Hadoop 的 MapReduce ，以及 Drill 、Hive 等是用于不同场景的数据分析工具。</p>
<h3 id="DataFrame-简单应用"><a href="#DataFrame-简单应用" class="headerlink" title="DataFrame 简单应用"></a>DataFrame 简单应用</h3><p>在shell里面输入</p>
<pre><code>spark-shell --packages com.databricks:spark-csv_2.11:1.1.0
</code></pre><p>加载完sparkshell及三方模块以后</p>
<pre><code>val df = sqlContext.read.format(&quot;com.databricks.spark.csv&quot;).option(&quot;header&quot;, &quot;true&quot;).load(&quot;/home/shiyanlou/1987.csv&quot;)
</code></pre><p>尝试取出这个数据集中的前 5 个数据，看一下是否读入成功。<br>请在 Spark Shell 中输入下面的代码。</p>
<pre><code>df.take(5)
</code></pre><p>在引入数据集之后，下一步要做的便是确保我们所有数据的格式是正确的。可以通过下面的代码来检查其格式。<br>请在 Spark Shell 中输入下面的代码。</p>
<pre><code>df.printSchema()
</code></pre><p>这里的每一项都是 String 类型。尽管这样不是很碍眼，但是在处理数据时多少都有一点不方便。我们可以尝试将某些列转换成其它的类型。方法是提取出某列然后转换。例如：<br> 请在 Spark Shell 中输入下面的代码。</p>
<pre><code>df.col(&quot;Year&quot;).cast(&quot;int&quot;)
</code></pre><p>当我们提取出某一列之后，又怎样将其放回去呢？下面我们提供一种 Spark 里改变 DataFrame 列类型的行之有效的办法。<br>请在 Spark Shell 中输入下面的代码。</p>
<pre><code>val df_1 = df.withColumnRenamed(&quot;Year&quot;,&quot;oldYear&quot;)
val df_2 = df_1.withColumn(&quot;Year&quot;,df_1.col(&quot;oldYear&quot;).cast(&quot;int&quot;)).drop(&quot;oldYear&quot;)
</code></pre><p>该想到用一个函数来转换列的格式类型。就像下面这样，请动手输入下面的代码来定义一个简单的函数：</p>
<pre><code>请在 Spark Shell 中输入下面的代码。
</code></pre><p>// 这里的类型转换参数就可以由我们自己随意决定了<br>    def convertColumn(df: org.apache.spark.sql.DataFrame, name:String, newType:String) = {<br>      val df_1 = df.withColumnRenamed(name, “swap”)<br>      df_1.withColumn(name, df_1.col(“swap”).cast(newType)).drop(“swap”)<br>    }</p>
<pre><code>val df_3 = convertColumn(df_2, &quot;ArrDelay&quot;, &quot;int&quot;)
val df_4 = convertColumn(df_2, &quot;DepDelay&quot;, &quot;int&quot;)
</code></pre><p> 计算平均延迟时间</p>
<pre><code>val averageDelays = df_4.groupBy(df_4.col(&quot;FlightNum&quot;)).agg(avg(df_4.col(&quot;ArrDelay&quot;)), avg(df_4.col(&quot;DepDelay&quot;)))
</code></pre><p>请输入下面的代码来缓存我们刚刚得到的数据。</p>
<pre><code>请在 Spark Shell 中输入下面的代码。
</code></pre><p>averageDelays.cache()</p>
<p>在缓存之后，我们如果要基于 averageDelays 做后续的计算，那么它的运算速度就会非常快了。 Spark 对于所有的变量几乎都是懒计算的，如果你不缓存的话，只有在执行行动操作（Action）时，它们才会被真正地计算。<br>下面我们来用一个行动操作看一下刚刚的计算结果。请输入这些代码。</p>
<pre><code>请在 Spark Shell 中输入下面的代码。

averageDelays.show()

averageDelays.orderBy(&quot;AVG(ArrDelay)&quot;).show()
averageDelays.sort($&quot;AVG(ArrDelay)&quot;.desc).show()
averageDelays.sort($&quot;AVG(ArrDelay)&quot;.desc, $&quot;AVG(DepDelay)&quot;.desc).show()
</code></pre><h3 id="在-Spark-中创建-DataFrame"><a href="#在-Spark-中创建-DataFrame" class="headerlink" title="在 Spark 中创建 DataFrame"></a>在 Spark 中创建 DataFrame</h3><p>有两个途径可以创建 DataFrame 。一是从现有的 RDD 创建，二是直接从数据源创建。</p>
<h4 id="从-RDD-创建-DataFrame"><a href="#从-RDD-创建-DataFrame" class="headerlink" title="从 RDD 创建 DataFrame"></a>从 RDD 创建 DataFrame</h4><p>#####（1） 由反射机制推断出模式</p>
<p>这里的模式指的就是 DataFrame 独有的模式（ Schema ）。这种方式通常适用于模式已知的情况，是将含有 case class 的 RDD 转化为 DataFrame 来实现的。</p>
<p>步骤是</p>
<h6 id="Step-1：引用必要的类"><a href="#Step-1：引用必要的类" class="headerlink" title="Step 1：引用必要的类"></a>Step 1：引用必要的类</h6><p>请在 Spark Shell 中输入下面的代码。</p>
<pre><code>import org.apache.spark.sql._

import sqlContext.implicits._
</code></pre><h6 id="Step-2：创建-RDD-。"><a href="#Step-2：创建-RDD-。" class="headerlink" title="Step 2：创建 RDD 。"></a>Step 2：创建 RDD 。</h6><p>//导入CSV文件并处理逗号分隔的数据</p>
<pre><code>val sfpdRDD = sc.textFile(&quot;/home/shiyanlou/SFPD.csv&quot;).map(inc =&gt; inc.split(&quot;,&quot;))
</code></pre><h6 id="Step-3：定义-case-class-。"><a href="#Step-3：定义-case-class-。" class="headerlink" title="Step 3：定义 case class 。"></a>Step 3：定义 case class 。</h6><pre><code>case class Incidents(incidentnum:String, category:String, description:String, dayofweek:String, date:String, time:String, pddistrict:String, resolution:String, address:String, x:String, y:String, location:String, pdid:String)
</code></pre><h6 id="Step-4：将-RDD-转换为含有-case-对象的-RDD-。"><a href="#Step-4：将-RDD-转换为含有-case-对象的-RDD-。" class="headerlink" title="Step 4：将 RDD 转换为含有 case 对象的 RDD 。"></a>Step 4：将 RDD 转换为含有 case 对象的 RDD 。</h6><pre><code>val sfpdCase = sfpdRDD.map(inc =&gt; Incidents(inc(0), inc(1), inc(2), inc(3), inc(4), inc(5), inc(6), inc(7), inc(8), inc(9), inc(10), inc(11), inc(12)))
</code></pre><h6 id="Step-5：隐式转换会将含有-case-对象的-RDD-转换为-DataFrame-，将-DataFrame-的一些操作和函数应用于这个-DataFrame-中。"><a href="#Step-5：隐式转换会将含有-case-对象的-RDD-转换为-DataFrame-，将-DataFrame-的一些操作和函数应用于这个-DataFrame-中。" class="headerlink" title="Step 5：隐式转换会将含有 case 对象的 RDD 转换为 DataFrame ，将 DataFrame 的一些操作和函数应用于这个 DataFrame 中。"></a>Step 5：隐式转换会将含有 case 对象的 RDD 转换为 DataFrame ，将 DataFrame 的一些操作和函数应用于这个 DataFrame 中。</h6><pre><code>val sfpdDF = sfpdCase.toDF()
</code></pre><h6 id="Step-6：将-DataFrame-注册为临时表，以便于在表上运行-SQL-查询"><a href="#Step-6：将-DataFrame-注册为临时表，以便于在表上运行-SQL-查询" class="headerlink" title="Step 6：将 DataFrame 注册为临时表，以便于在表上运行 SQL 查询"></a>Step 6：将 DataFrame 注册为临时表，以便于在表上运行 SQL 查询</h6><pre><code>sfpdDF.registerTempTable(&quot;sfpd&quot;)
</code></pre><p>#####（2）通过编程方式构建模式</p>
<p>这种方式适用于列和类型在运行时不可知的情况，我们就需要手动地去构建 DataFrame 的模式。通常 DataFrame 的模式在动态变化时才会使用这种方式。</p>
<h4 id="从数据源创建-DataFrame"><a href="#从数据源创建-DataFrame" class="headerlink" title="从数据源创建 DataFrame"></a>从数据源创建 DataFrame</h4><p>现有的大数据应用通常需要搜集和分析来自不同的数据源的数据。而 DataFrame 支持 JSON 文件、 Parquet 文件、 Hive 表等数据格式。它能从本地文件系统、分布式文件系统（HDFS）、云存储（Amazon S3）和外部的关系数据库系统（通过JDBC，在Spark 1.4版本起开始支持）等地方读取数据。另外，通过 Spark SQL 的外部数据源 API ，DataFrame 能够被扩展，以支持第三方的数据格式或数据源。在实验楼提供的 DataFrame 入门课程中，我们就用到了一个十分流行的第三方CSV格式扩展。除此之外，它还支持 Avro （一个数据序列化的系统）、ElasticSearch、Cassandra</p>
<p>扩展阅读：</p>
<p>CSV：    逗号分隔值（ Comma-Separated Values ），其文件以纯文本形式存储表格数据。请参考：<a href="http://commons.apache.org/proper/commons-csv/" target="_blank" rel="external">http://commons.apache.org/proper/commons-csv/</a> 。<br>    Apache Avro： 一个数据序列化的系统，相当于基于二进制数据传输高性能的中间件。请参考：<a href="https://avro.apache.org/docs/current/" target="_blank" rel="external">https://avro.apache.org/docs/current/</a> 。<br>    Elasticsearch：一个基于 Lucene 的搜索服务器。提供了一个基于 RESTful web 接口的分布式全文搜索引擎。请参考：<a href="https://www.elastic.co/products/elasticsearch/" target="_blank" rel="external">https://www.elastic.co/products/elasticsearch/</a> 。<br>    Apache Cassandra：一套开源分布式NoSQL数据库系统。请参考：<a href="http://cassandra.apache.org/" target="_blank" rel="external">http://cassandra.apache.org/</a> 。</p>
<p>// 默认格式parquet文件的加载方法，需要给出文件的路径<br>sqlContext.read.load(“/home/shiyanlou/data.parquet”)</p>
<p>// 加载其他格式的文件，需要在format方法中指明格式<br>sqlContext.read.format(“json”).load(“/home/shiyanlou/data.json”)<br>常用 DataFrame 操作</p>
<p>对于 DataFrame 而言，经常用到的行动操作（Action）主要有：</p>
<pre><code>count()：返回当前 DataFrame 中含有的行的数目。
collect()：以数组的形式，返回当前 DataFrame 中的所有行。
head()：返回当前 DataFrame 中的第一行数据。
first()：功能与 head() 相同，返回其中第一行的数据。
show()：输出 DataFrame 中的前面几行数据，默认为前 20 行，输出的数据将以表格形式呈现。
take(n:int)：返回当前 DataFrame 中前面 n 行的数据，行数由参数确定。
describe(cols:String*)：计算数值列的统计值（这些指标有计数、均值、标准差、最大值和最小值等）
</code></pre><p>除此之外，DataFrame 还有以下这些经常用到的基础函数：</p>
<pre><code>columns：以数组的形式，返回当前 DataFrame 中所有的列名。
cache()：将当前 DataFrame 缓存至内存或硬盘中（缓存方式由其他机制决定）。
persist()：持久化当前 DataFrame 。
unpersist()：与上面的持久化方法作用相反，是去除该 DataFrame 的持久化。
printSchema()：以“树目录”的形式打印表格的字段名和类型（相当于其模式）。
dtypes：以数组的形式，返回所有的列名及其数据类型。
toDF()：在重新指定列名后，返回一个新的 DataFrame 。
registerTempTable()：将指定的名字作为参数，将当前 DataFrame 注册为一个临时表。
isLocal：返回一个Boolean的结果，用于判断 collect 操作和 take 操作是否可以本地运行。
explain()：在控制台输出物理计划（Catalyst Optimizer）
</code></pre><p>由于 DataFrame 本身也是一个 RDD ，所以一些 RDD 具有的操作，DataFrame 也有。例如：</p>
<pre><code>map()
flatMap()
foreach()
repartition()
foreachPartition()
</code></pre><p>这些方法如何使用已经在 RDD 相关的课程中进行了讲解，此处不再赘述。</p>
<p>最后，我们再提供一些常用的语言集成查询函数。这些函数的作用类似于 SQL 语句，通常与 Spark SQL 结合使用。</p>
<pre><code>select()：根据参数提供的条件，选择一个列的集合。
where(condition)：根据参数提供的条件，过滤指定的行。与此作用相同的还有 filter(expr) 。
sort()：根据参数提供的表达式，返回一个按照该表达式排序的新的 DataFrame 。
drop()：移除参数指定的列，然后返回一个新的 DataFrame 。
distinct()：返回一个仅包含 DataFrame 的唯一行的新 DataFrame 。
col()：选择参数指定的列，并将其以 Column 的形式返回。
as()：以参数指定的名称作为当前 DataFrame 的别名，返回一个新的 DataFrame 。
agg(expr, exprs)：聚集整个 DataFrame 。
except(other)：返回一个带有行的新 DataFrame ，这里的行指的是当前 DataFrame 不在其他 DataFrame 中被包含的行。
groupBy(cols:Columns)：使用指定的列来分组 DataFrame 。
join(DataFrame, joinExpr)：使用指定的联合表达式，联合其他的 DataFrame 。
</code></pre><p>这些函数的参数形式、返回值类型，请通过最新的 DataFrame API 文档<a href="https://spark.apache.org/docs/1.6.1/api/scala/index.html#org.apache.spark.sql.DataFrame" title="DataFrame API文档" target="_blank" rel="external">https://spark.apache.org/docs/1.6.1/api/scala/index.html#org.apache.spark.sql.DataFrame</a>获取</p>
<pre><code>val top3Address = sqlContext.sql(&quot;SELECT address, count(incidentnum) AS inccount FROM sfpd GROUP BY address ORDER BY inccount DESC LIMIT 3&quot;).show
</code></pre><p>我们在常用 DataFrame 操作一节中讲述了行动操作、基础函数等，这里还需要再补充一下输出操作会用到的函数。输出的意思即保存，我们通常会将一些中间结果或者最终结果存储起来，作为下一步分析的基础。</p>
<p>这些用于输出的操作主要有：</p>
<pre><code>save(source, mode, options)：基于给定的数据源、保存模式和选项，将 DataFrame 的内容保存下来。
saveAsTable(tableName, source, mode, options)：基于给定的数据源、保存模式和选项，将 DataFrame 的内容保存为表。
saveAsParquetFile(path)：将 DataFrame 的内容保存为 parquet 文件，存放于指定的路径。
insertIntoJDBC(url, name, over)：将 DataFrame 的内容保存至 JDBC 源，路径由参数 url 给出，需要指定表名和覆盖模式
</code></pre><p>但我们如果需要保存为 JSON 格式，又应该怎么办呢？我们知道 JSON 文件的本质是文本，所以可通过下面的代码来实现：</p>
<p>numAddDesc.toJSON.saveAsTextFile(“/home/shiyanlou/numAddress”)<br>注意此处保存的对象 numAddDesc 是一个 DataFrame 对象。在保存完毕后，我们可以在 /home/shiyanlou 目录下看到一个名为 numAddress 的文件夹<br>在 Spark 1.4 及之后的版本中，这些保存的方法被通用的格式所取代。首先调用 write() 方法进行写操作，可以通过 format() 函数指定格式，并且通过 mode() 函数指定存储模式，用 save() 函数指定路径。于是刚刚的保存操作可以写成：</p>
<p>numAddDesc.write.format(“json”).mode(“overwrite”).save(“/home/shiyanlou/numAddDesc2”)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/22/hadoop学习笔记-1-单机环境搭建与词频统计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/22/hadoop学习笔记-1-单机环境搭建与词频统计/" itemprop="url">hadoop学习笔记(1)单机环境搭建与词频统计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T09:37:07+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/22/hadoop学习笔记-1-单机环境搭建与词频统计/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/22/hadoop学习笔记-1-单机环境搭建与词频统计/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-安装及配置依赖的软件包"><a href="#一-安装及配置依赖的软件包" class="headerlink" title="一.安装及配置依赖的软件包"></a>一.安装及配置依赖的软件包</h3><p>安装openssh-server、java、rsync等,配置ssh免密码登录<br>    $ sudo apt-get update<br>    $ sudo apt-get install openssh-server rsync<br>    $ sudo service ssh restart<br>    $ sudo apt-get install openjdk-7-jdk<br>    $ java -version<br>    $ su -l hadoop<br>    $ ssh-keygen -t rsa   #一路回车<br>    $ cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys<br>    $ sudo chmod 600 .ssh/authorized_keys<br>    $ ssh localhost</p>
<h3 id="二-下载并安装Hadoop"><a href="#二-下载并安装Hadoop" class="headerlink" title="二.下载并安装Hadoop"></a>二.下载并安装Hadoop</h3><pre><code>$  su hadoop
$  hadoop
$  sudo wget http://labfile.oss.aliyuncs.com/hadoop-2.6.0.tar.gz
$ sudo tar -zxvf hadoop-2.6.0.tar.gz
$ sudo mv hadoop-2.6.0 /usr/local/hadoop
$ sudo chmod 777 /usr/local/hadoop
$ vim /home/hadoop/.bashrc
</code></pre><p>在/home/hadoop/.bashrc文件末尾添加下列内容：</p>
<pre><code>#HADOOP START
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
export HADOOP_INSTALL=/usr/local/hadoop
export PATH=$PATH:$HADOOP_INSTALL/bin
export PATH=$PATH:$HADOOP_INSTALL/sbin
export HADOOP_MAPRED_HOME=$HADOOP_INSTALL
export HADOOP_COMMON_HOME=$HADOOP_INSTALL
export HADOOP_HDFS_HOME=$HADOOP_INSTALL
export YARN_HOME=$HADOOP_INSTALL
export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_INSTALL/lib/native
export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_INSTALL/lib&quot;
#HADOOP END
</code></pre><p>保存退出后，激活新加的环境变量<br>    $ source ~/.bashrc</p>
<h3 id="三-测试验证"><a href="#三-测试验证" class="headerlink" title="三.测试验证"></a>三.测试验证</h3><p>创建输入的数据，暂时采用/etc/protocols文件作为测试</p>
<pre><code>$ cd /usr/local/hadoop
$ sudo mkdir input
$ sudo cp /etc/protocols ./input
</code></pre><p>执行Hadoop WordCount应用（词频统计）</p>
<pre><code>$ bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-sources.jar org.apache.hadoop.examples.WordCount input output
</code></pre><p>查看生成的单词统计数据</p>
<pre><code>$ cat output/*
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/20/计算机网络小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/计算机网络小结/" itemprop="url">计算机网络小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T15:51:26+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/20/计算机网络小结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/20/计算机网络小结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <table>
<thead>
<tr>
<th></th>
<th>数据单元</th>
</tr>
</thead>
<tbody>
<tr>
<td>链路层</td>
<td>帧</td>
</tr>
<tr>
<td>网络层</td>
<td>IP数据报</td>
</tr>
<tr>
<td>网络层</td>
<td>IP数据报</td>
</tr>
<tr>
<td>链路层</td>
<td>帧</td>
</tr>
</tbody>
</table>
<hr>
<p>IP 协议位于<strong>网络层</strong>，它是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。IP 协议提供的是<code>不可靠 、 无连接</code>的数据报传送服务。</p>
<p><strong>不可靠</strong>（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。</p>
<p><strong>无连接</strong>（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达</p>
<hr>
<p><strong>链路层</strong>的工作就是把网络层交下来的 IP 数据报 封装为 帧（frame）发送到链路上，以及把接收到的帧中的数据取出并上交给网络层<br><img src="http://i.imgur.com/ZYmU06j.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/20/Git常见命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/Git常见命令/" itemprop="url">Git常见命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T15:13:00+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/20/Git常见命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/20/Git常见命令/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://i.imgur.com/JpUlmoj.png" alt=""><br>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="1-新建代码库"><a href="#1-新建代码库" class="headerlink" title="1.新建代码库"></a>1.新建代码库</h3><pre><code># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<pre><code># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre><h3 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3.增加/删除文件"></a>3.增加/删除文件</h3><pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre><h3 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4.代码提交"></a>4.代码提交</h3><pre><code># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre><h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5.分支"></a>5.分支</h3><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch –track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch –set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin –delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre><h3 id="6-标签"><a href="#6-标签" class="headerlink" title="6.标签"></a>6.标签</h3><pre><code># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre><h3 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7.查看信息"></a>7.查看信息</h3><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre><h3 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8.远程同步"></a>8.远程同步</h3><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre><h3 id="9-撤销"><a href="#9-撤销" class="headerlink" title="9.撤销"></a>9.撤销</h3><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre><h3 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h3><pre><code># 生成一个可供发布的压缩包
$ git archive
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://github.com/gayTao/gayTao.github.io.git/2017/05/07/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王套套">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="桃树下的白手套">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-07T09:21:32+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/07/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/07/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/timg.jpg"
               alt="王套套" />
          <p class="site-author-name" itemprop="name">王套套</p>
           
              <p class="site-description motion-element" itemprop="description">每个人的心底都有一座坟墓，是用来埋葬所爱的人的</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/gayTao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/wei-ting-72?utm_source=qq&utm_medium=social" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王套套</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
